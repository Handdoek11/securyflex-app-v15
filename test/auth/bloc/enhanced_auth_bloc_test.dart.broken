import 'package:flutter_test/flutter_test.dart';
import 'package:bloc_test/bloc_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:securyflex_app/auth/bloc/auth_bloc.dart';
import 'package:securyflex_app/auth/bloc/auth_event.dart';
import 'package:securyflex_app/auth/bloc/auth_state.dart';
import 'package:securyflex_app/auth/repository/auth_repository.dart';
import 'package:securyflex_app/auth/services/totp_service.dart';
import 'package:securyflex_app/auth/services/sms_2fa_service.dart';
import 'package:securyflex_app/auth/services/biometric_auth_service.dart';
import 'package:securyflex_app/auth/services/kvk_api_service.dart';
import 'package:securyflex_app/auth/services/wpbr_verification_service.dart';
import 'package:securyflex_app/auth/models/enhanced_auth_models.dart';
import 'package:securyflex_app/core/bloc/error_handler.dart';

/// Mock AuthRepository for testing
class MockAuthRepository extends Mock implements AuthRepository {}

/// Mock Firebase User for testing
class MockUser extends Mock implements User {}

/// Mock TOTPService for testing
class MockTOTPService extends Mock {}

/// Mock SMS2FAService for testing  
class MockSMS2FAService extends Mock {}

/// Mock BiometricAuthService for testing
class MockBiometricAuthService extends Mock {}

void main() {
  group('Enhanced Auth BLoC Tests', () {
    late AuthBloc authBloc;
    late MockAuthRepository mockAuthRepository;
    late MockUser mockUser;

    setUp(() {
      mockAuthRepository = MockAuthRepository();
      mockUser = MockUser();
      
      // Default mocks
      when(() => mockAuthRepository.currentUser).thenReturn(null);
      when(() => mockAuthRepository.authStateChanges).thenAnswer(
        (_) => Stream.fromIterable([null]),
      );
      when(() => mockUser.uid).thenReturn('test-user-123');
      when(() => mockUser.email).thenReturn('test@example.com');
      
      authBloc = AuthBloc(repository: mockAuthRepository);
    });

    tearDown(() {
      authBloc.close();
    });

    group('Enhanced Authentication Events', () {
      group('Two-Factor Authentication', () {
        blocTest<AuthBloc, AuthState>(
          'should enable SMS 2FA successfully',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthEnable2FA(
            method: TwoFactorMethod.sms,
            phoneNumber: '+31612345678',
          )),
          expect: () => [
            AuthAdvancedLoading(operation: 'enable_2fa'),
            isA<AuthTwoFactorEnabled>()
              .having((state) => state.method, 'method', TwoFactorMethod.sms)
              .having((state) => state.config, 'config', isA<TwoFactorConfig>()),
          ],
          verify: (bloc) {
            // Verify that proper SMS 2FA setup was called
            // This would be mocked in actual implementation
          },
        );

        blocTest<AuthBloc, AuthState>(
          'should reject SMS 2FA setup without phone number',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthEnable2FA(
            method: TwoFactorMethod.sms,
            // phoneNumber missing
          )),
          expect: () => [
            AuthAdvancedLoading(operation: 'enable_2fa'),
            AuthError(AppError(
              code: 'validation_error',
              message: 'Phone number required for SMS 2FA',
              category: ErrorCategory.validation,
            )),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should generate TOTP secret and QR code',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthGenerateTOTP('test@example.com')),
          expect: () => [
            AuthAdvancedLoading(operation: 'generate_totp'),
            isA<AuthTOTPSetup>()
              .having((state) => state.secret, 'secret', isNotEmpty)
              .having((state) => state.qrCodeData, 'qrCodeData', isNotEmpty)
              .having((state) => state.userEmail, 'userEmail', 'test@example.com')
              .having((state) => state.backupCodes, 'backupCodes', isNotEmpty),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should verify 2FA code successfully',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthVerify2FA(
            code: '123456',
            method: TwoFactorMethod.totp,
          )),
          expect: () => [
            AuthAdvancedLoading(operation: 'verify_2fa'),
            AuthTwoFactorVerified(
              method: TwoFactorMethod.totp,
              wasBackupCode: false,
            ),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should handle backup code verification',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthVerify2FA(
            code: 'BACKUP-CODE-123',
            method: TwoFactorMethod.backupCode,
          )),
          expect: () => [
            AuthAdvancedLoading(operation: 'verify_2fa'),
            isA<AuthTwoFactorVerified>()
              .having((state) => state.method, 'method', TwoFactorMethod.backupCode)
              .having((state) => state.wasBackupCode, 'wasBackupCode', true)
              .having((state) => state.remainingBackupCodes, 'remainingBackupCodes', greaterThanOrEqualTo(0)),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should disable 2FA with valid verification',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthDisable2FA('123456')),
          expect: () => [
            AuthAdvancedLoading(operation: 'disable_2fa'),
            AuthTwoFactorDisabled(),
          ],
        );
      });

      group('Biometric Authentication', () {
        blocTest<AuthBloc, AuthState>(
          'should check biometric availability',
          build: () => authBloc,
          act: (bloc) => bloc.add(AuthCheckBiometricAvailability()),
          expect: () => [
            AuthAdvancedLoading(operation: 'check_biometric_availability'),
            isA<AuthBiometricAvailability>()
              .having((state) => state.isAvailable, 'isAvailable', isA<bool>())
              .having((state) => state.isSupported, 'isSupported', isA<bool>())
              .having((state) => state.availableTypes, 'availableTypes', isA<List<BiometricType>>())
              .having((state) => state.reason, 'reason', isA<String?>())
              .having((state) => state.errorCode, 'errorCode', isA<String?>()),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should setup biometric authentication',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthSetupBiometric(
            enabledTypes: [BiometricType.fingerprint, BiometricType.face],
          )),
          expect: () => [
            AuthAdvancedLoading(operation: 'setup_biometric'),
            isA<AuthBiometricEnabled>()
              .having((state) => state.config, 'config', isA<BiometricConfig>())
              .having((state) => state.enabledTypes, 'enabledTypes', [BiometricType.fingerprint, BiometricType.face]),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should authenticate with biometrics successfully',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthBiometricAuth(
            biometricOnly: true,
            localizedFallbackTitle: 'Wachtwoord gebruiken',
          )),
          expect: () => [
            AuthAdvancedLoading(operation: 'biometric_auth'),
            isA<AuthBiometricAuthenticated>()
              .having((state) => state.authenticationType, 'authenticationType', isA<BiometricType>())
              .having((state) => state.timestamp, 'timestamp', isA<DateTime>()),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should disable biometric authentication',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthDisableBiometric('123456')),
          expect: () => [
            AuthAdvancedLoading(operation: 'disable_biometric'),
            AuthBiometricDisabled(),
          ],
        );
      });

      group('SMS Verification', () {
        blocTest<AuthBloc, AuthState>(
          'should send SMS verification code',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthSendSMSCode(
            phoneNumber: '+31612345678',
            isResend: false,
          )),
          expect: () => [
            AuthAdvancedLoading(operation: 'send_sms'),
            isA<AuthSMSCodeSent>()
              .having((state) => state.verificationId, 'verificationId', isA<String>())
              .having((state) => state.obfuscatedPhoneNumber, 'obfuscatedPhoneNumber', '06****5678')
              .having((state) => state.cooldownSeconds, 'cooldownSeconds', 60)
              .having((state) => state.isResend, 'isResend', false)
              .having((state) => state.successMessage, 'successMessage', isA<String>()),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should handle SMS resend with cooldown',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthSendSMSCode(
            phoneNumber: '+31612345678',
            isResend: true,
          )),
          expect: () => [
            AuthAdvancedLoading(operation: 'send_sms'),
            anyOf([
              AuthSMSCodeSent(
                verificationId: isA<String>(),
                obfuscatedPhoneNumber: '06****5678',
                cooldownSeconds: isA<int>(),
                isResend: true,
                successMessage: isA<String>(),
              ),
              AuthError(isA<AppError>()) // If rate limited
            ]),
          ],
        );
      });

      group('Security Configuration', () {
        blocTest<AuthBloc, AuthState>(
          'should get security configuration',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthGetSecurityConfig()),
          expect: () => [
            AuthSecurityConfig(
              twoFactorConfig: isA<TwoFactorConfig>(),
              biometricConfig: isA<BiometricConfig>(),
              currentLevel: isA<AuthenticationLevel>(),
              recentEvents: isA<List>(),
              preferences: isA<Map<String, dynamic>>(),
            ),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should update security preferences',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthUpdateSecurityPreferences(
            preferences: {
              'biometricEnabled': true,
              'smsBackup': true,
              'sessionTimeout': 1800,
            },
          )),
          expect: () => [
            AuthProfileUpdateSuccess(
              updatedData: {
                'biometricEnabled': true,
                'smsBackup': true,
                'sessionTimeout': 1800,
              },
              successMessage: 'Beveiligingsinstellingen bijgewerkt',
            ),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should log security events',
          build: () => authBloc,
          seed: () => AuthAuthenticated(
            firebaseUser: mockUser,
            userId: 'test-user-123',
            userType: 'guard',
            userName: 'Test User',
            userEmail: 'test@example.com',
            userData: {},
          ),
          act: (bloc) => bloc.add(AuthLogSecurityEvent(
            eventType: AuthSecurityEventType.loginSuccess,
            description: 'Successful biometric authentication',
            metadata: {'method': 'fingerprint'},
          )),
          expect: () => [
            AuthSecurityEventLogged(
              event: isA<AuthSecurityEvent>(),
            ),
          ],
        );
      });
    });

    group('Dutch Business Logic Events', () {
      group('KvK Validation', () {
        blocTest<AuthBloc, AuthState>(
          'should validate KvK number successfully',
          build: () => authBloc,
          act: (bloc) => bloc.add(AuthValidateKvK(
            kvkNumber: '12345678',
            requireSecurityEligibility: true,
          )),
          expect: () => [
            AuthKvKValidating(
              '12345678',
              loadingMessage: 'KvK nummer valideren...',
              currentStep: 'Verbinding maken met KvK API',
              attemptNumber: 1,
            ),
            AuthKvKValidation(
              kvkNumber: '12345678',
              isValid: isA<bool>(),
              kvkData: isA<Map<String, dynamic>?>(),
              isSecurityEligible: isA<bool>(),
              eligibilityScore: isA<double>(),
              eligibilityReasons: isA<List<String>>(),
              errorMessage: null,
            ),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should handle invalid KvK format',
          build: () => authBloc,
          act: (bloc) => bloc.add(AuthValidateKvK(
            kvkNumber: '1234567', // Invalid: too short
          )),
          expect: () => [
            AuthKvKValidation(
              kvkNumber: '1234567',
              isValid: false,
              errorMessage: isA<String>(),
            ),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should validate multiple KvK numbers',
          build: () => authBloc,
          act: (bloc) => bloc.add(AuthValidateMultipleKvK(
            kvkNumbers: ['12345678', '87654321', '11111111'],
          )),
          expect: () => [
            AuthMultipleKvKValidating(
              kvkNumbers: ['12345678', '87654321', '11111111'],
              currentIndex: 0,
              loadingMessage: 'KvK nummer 1 van 3 valideren...',
            ),
            AuthMultipleKvKValidating(
              kvkNumbers: ['12345678', '87654321', '11111111'],
              currentIndex: 1,
              loadingMessage: 'KvK nummer 2 van 3 valideren...',
            ),
            AuthMultipleKvKValidating(
              kvkNumbers: ['12345678', '87654321', '11111111'],
              currentIndex: 2,
              loadingMessage: 'KvK nummer 3 van 3 valideren...',
            ),
            AuthMultipleKvKValidation(
              results: isA<Map<String, AuthKvKValidation>>(),
              successCount: isA<int>(),
              errorCount: isA<int>(),
            ),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should get detailed KvK information',
          build: () => authBloc,
          act: (bloc) => bloc.add(AuthGetKvKDetails(
            kvkNumber: '12345678',
          )),
          expect: () => [
            AuthKvKValidating(
              '12345678',
              loadingMessage: 'Bedrijfsgegevens ophalen...',
              currentStep: 'Uitgebreide gegevens laden',
            ),
            AuthKvKDetails(
              kvkNumber: '12345678',
              companyDetails: isA<Map<String, dynamic>>(),
              isSecurityEligible: isA<bool>(),
              eligibilityScore: isA<double>(),
              businessActivities: isA<List<String>>(),
            ),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should calculate security eligibility',
          build: () => authBloc,
          act: (bloc) => bloc.add(AuthCalculateSecurityEligibility(
            kvkNumber: '12345678',
          )),
          expect: () => [
            AuthKvKValidating(
              '12345678',
              loadingMessage: 'Beveiligingsgeschiktheid berekenen...',
              currentStep: 'Geschiktheid analyseren',
            ),
            AuthSecurityEligibilityResult(
              kvkNumber: '12345678',
              isEligible: isA<bool>(),
              score: isA<double>(),
              reasons: isA<List<String>>(),
              requirements: isA<List<String>>(),
            ),
          ],
        );
      });

      group('WPBR Validation', () {
        blocTest<AuthBloc, AuthState>(
          'should validate WPBR certificate',
          build: () => authBloc,
          act: (bloc) => bloc.add(AuthValidateWPBR(
            wpbrNumber: 'WPBR-123456',
            certificateFilePath: '/path/to/certificate.pdf',
          )),
          expect: () => [
            AuthWPBRValidating('WPBR-123456'),
            AuthWPBRValidation(
              wpbrNumber: 'WPBR-123456',
              isValid: isA<bool>(),
              wpbrData: isA<Map<String, dynamic>?>(),
              errorMessage: isA<String?>(),
            ),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should handle invalid WPBR format',
          build: () => authBloc,
          act: (bloc) => bloc.add(AuthValidateWPBR(
            wpbrNumber: 'INVALID',
          )),
          expect: () => [
            AuthWPBRValidation(
              wpbrNumber: 'INVALID',
              isValid: false,
              errorMessage: isA<String>(),
            ),
          ],
        );
      });

      group('Postal Code Validation', () {
        blocTest<AuthBloc, AuthState>(
          'should validate Dutch postal code',
          build: () => authBloc,
          act: (bloc) => bloc.add(AuthValidatePostalCode(
            postalCode: '1234AB',
          )),
          expect: () => [
            AuthPostalCodeValidation(
              postalCode: '1234AB',
              isValid: true,
              formattedPostalCode: '1234 AB',
              errorMessage: null,
            ),
          ],
        );

        blocTest<AuthBloc, AuthState>(
          'should reject invalid postal code',
          build: () => authBloc,
          act: (bloc) => bloc.add(AuthValidatePostalCode(
            postalCode: '12345',
          )),
          expect: () => [
            AuthPostalCodeValidation(
              postalCode: '12345',
              isValid: false,
              formattedPostalCode: null,
              errorMessage: isA<String>(),
            ),
          ],
        );
      });
    });

    group('Error Handling', () {
      blocTest<AuthBloc, AuthState>(
        'should handle authentication errors gracefully',
        build: () => authBloc,
        seed: () => AuthAuthenticated(
          firebaseUser: mockUser,
          userId: 'test-user-123',
          userType: 'guard',
          userName: 'Test User',
          userEmail: 'test@example.com',
          userData: {},
        ),
        act: (bloc) {
          // Mock service to throw error
          when(() => mockAuthRepository.signOut()).thenThrow(Exception('Network error'));
          bloc.add(AuthLogout());
        },
        expect: () => [
          AuthLoading(loadingMessage: 'Uitloggen...'),
          AuthError(isA<AppError>()),
        ],
      );

      blocTest<AuthBloc, AuthState>(
        'should handle KvK service errors',
        build: () => authBloc,
        act: (bloc) => bloc.add(AuthValidateKvK(
          kvkNumber: '99999999', // This would trigger an error in the service
        )),
        expect: () => [
          AuthKvKValidating(
            '99999999',
            loadingMessage: 'KvK nummer valideren...',
            currentStep: 'Verbinding maken met KvK API',
            attemptNumber: 1,
          ),
          anyOf([
            AuthKvKValidation(
              kvkNumber: '99999999',
              isValid: isA<bool>(),
              kvkData: isA<Map<String, dynamic>?>(),
              errorMessage: isA<String?>(),
            ),
            AuthError(isA<AppError>()),
          ]),
        ],
      );

      blocTest<AuthBloc, AuthState>(
        'should handle unauthenticated user for secure operations',
        build: () => authBloc,
        seed: () => AuthUnauthenticated(),
        act: (bloc) => bloc.add(AuthEnable2FA(
          method: TwoFactorMethod.sms,
          phoneNumber: '+31612345678',
        )),
        expect: () => [
          AuthAdvancedLoading(operation: 'enable_2fa'),
          AuthError(isA<AppError>()),
        ],
      );
    });

    group('State Transitions and Complex Flows', () {
      blocTest<AuthBloc, AuthState>(
        'should handle complete 2FA setup flow',
        build: () => authBloc,
        seed: () => AuthAuthenticated(
          firebaseUser: mockUser,
          userId: 'test-user-123',
          userType: 'guard',
          userName: 'Test User',
          userEmail: 'test@example.com',
          userData: {},
        ),
        act: (bloc) async {
          // Step 1: Generate TOTP
          bloc.add(AuthGenerateTOTP(userEmail: 'test@example.com'));
          await Future.delayed(Duration(milliseconds: 100));
          
          // Step 2: Verify TOTP code
          bloc.add(AuthVerify2FA(code: '123456', method: TwoFactorMethod.totp));
          await Future.delayed(Duration(milliseconds: 100));
          
          // Step 3: Generate backup codes
          bloc.add(AuthGenerateBackupCodes(count: 10));
        },
        skip: 0,
        expect: () => [
          // TOTP Generation
          AuthAdvancedLoading(operation: 'generate_totp'),
          AuthTOTPSetup(
            secret: isA<String>(),
            qrCodeData: isA<String>(),
            userEmail: 'test@example.com',
            backupCodes: isA<List<BackupCode>>(),
          ),
          // TOTP Verification
          AuthAdvancedLoading(operation: 'verify_2fa'),
          AuthTwoFactorVerified(
            method: TwoFactorMethod.totp,
            wasBackupCode: false,
          ),
          // Backup Code Generation
          AuthAdvancedLoading(operation: 'generate_backup_codes'),
          AuthBackupCodesGenerated(
            backupCodes: isA<List<BackupCode>>(),
          ),
        ],
      );

      blocTest<AuthBloc, AuthState>(
        'should handle complete company onboarding flow',
        build: () => authBloc,
        act: (bloc) async {
          // Step 1: Validate KvK
          bloc.add(AuthValidateKvK(
            kvkNumber: '12345678',
            requireSecurityEligibility: true,
          ));
          await Future.delayed(Duration(milliseconds: 100));
          
          // Step 2: Get detailed company info
          bloc.add(AuthGetKvKDetails(kvkNumber: '12345678'));
          await Future.delayed(Duration(milliseconds: 100));
          
          // Step 3: Calculate eligibility
          bloc.add(AuthCalculateSecurityEligibility(kvkNumber: '12345678'));
        },
        skip: 0,
        expect: () => [
          // KvK Validation
          AuthKvKValidating(
            '12345678',
            loadingMessage: 'KvK nummer valideren...',
            currentStep: 'Verbinding maken met KvK API',
            attemptNumber: 1,
          ),
          AuthKvKValidation(
            kvkNumber: '12345678',
            isValid: isA<bool>(),
            kvkData: isA<Map<String, dynamic>?>(),
            isSecurityEligible: isA<bool>(),
            eligibilityScore: isA<double>(),
            eligibilityReasons: isA<List<String>>(),
          ),
          // Detailed Company Info
          AuthKvKValidating(
            '12345678',
            loadingMessage: 'Bedrijfsgegevens ophalen...',
            currentStep: 'Uitgebreide gegevens laden',
          ),
          AuthKvKDetails(
            kvkNumber: '12345678',
            companyDetails: isA<Map<String, dynamic>>(),
            isSecurityEligible: isA<bool>(),
            eligibilityScore: isA<double>(),
            businessActivities: isA<List<String>>(),
          ),
          // Security Eligibility
          AuthKvKValidating(
            '12345678',
            loadingMessage: 'Beveiligingsgeschiktheid berekenen...',
            currentStep: 'Geschiktheid analyseren',
          ),
          AuthSecurityEligibilityResult(
            kvkNumber: '12345678',
            isEligible: isA<bool>(),
            score: isA<double>(),
            reasons: isA<List<String>>(),
            requirements: isA<List<String>>(),
          ),
        ],
      );
    });

    group('Performance and Edge Cases', () {
      blocTest<AuthBloc, AuthState>(
        'should handle rapid successive events without state corruption',
        build: () => authBloc,
        seed: () => AuthAuthenticated(
          firebaseUser: mockUser,
          userId: 'test-user-123',
          userType: 'guard',
          userName: 'Test User',
          userEmail: 'test@example.com',
          userData: {},
        ),
        act: (bloc) {
          // Send multiple events rapidly
          for (int i = 0; i < 5; i++) {
            bloc.add(AuthGetSecurityConfig());
          }
        },
        expect: () => [
          // Should handle all requests gracefully
          AuthSecurityConfig(
            twoFactorConfig: isA<TwoFactorConfig>(),
            biometricConfig: isA<BiometricConfig>(),
            currentLevel: isA<AuthenticationLevel>(),
            recentEvents: isA<List>(),
            preferences: isA<Map<String, dynamic>>(),
          ),
          // Additional states may follow depending on implementation
        ],
      );

      blocTest<AuthBloc, AuthState>(
        'should maintain state consistency during concurrent operations',
        build: () => authBloc,
        seed: () => AuthAuthenticated(
          firebaseUser: mockUser,
          userId: 'test-user-123',
          userType: 'guard',
          userName: 'Test User',
          userEmail: 'test@example.com',
          userData: {},
        ),
        act: (bloc) {
          // Concurrent security operations
          bloc.add(AuthEnable2FA(method: TwoFactorMethod.sms, phoneNumber: '+31612345678'));
          bloc.add(AuthSetupBiometric(enabledTypes: [BiometricType.fingerprint]));
          bloc.add(AuthGetSecurityConfig());
        },
        skip: 0,
        expect: () => [
          // Should handle concurrent operations properly
          isA<AuthState>(),
          isA<AuthState>(),
          isA<AuthState>(),
        ],
      );

      test('should properly dispose resources on close', () async {
        // Create a new bloc for this test
        final testBloc = AuthBloc(repository: mockAuthRepository);
        
        // Add some events to initialize internal state
        testBloc.add(AuthInitialize());
        
        // Wait for initial processing
        await Future.delayed(Duration(milliseconds: 100));
        
        // Close the bloc
        await testBloc.close();
        
        // Verify that the bloc is properly closed
        expect(testBloc.isClosed, isTrue);
      });
    });

    group('Dutch Localization Validation', () {
      blocTest<AuthBloc, AuthState>(
        'should provide Dutch error messages',
        build: () => authBloc,
        act: (bloc) => bloc.add(AuthValidateKvK(
          kvkNumber: '', // Empty KvK number should trigger Dutch error
        )),
        expect: () => [
          AuthKvKValidation(
            kvkNumber: '',
            isValid: false,
            errorMessage: contains('KvK'), // Should contain Dutch text
          ),
        ],
      );

      blocTest<AuthBloc, AuthState>(
        'should provide Dutch loading messages',
        build: () => authBloc,
        act: (bloc) => bloc.add(AuthValidateKvK(
          kvkNumber: '12345678',
        )),
        expect: () => [
          AuthKvKValidating(
            '12345678',
            loadingMessage: contains('valideren'), // Dutch loading message
            currentStep: contains('KvK'), // Dutch step description
            attemptNumber: 1,
          ),
          isA<AuthKvKValidation>(), // Final result
        ],
      );

      blocTest<AuthBloc, AuthState>(
        'should provide Dutch success messages',
        build: () => authBloc,
        seed: () => AuthAuthenticated(
          firebaseUser: mockUser,
          userId: 'test-user-123',
          userType: 'guard',
          userName: 'Test User',
          userEmail: 'test@example.com',
          userData: {},
        ),
        act: (bloc) => bloc.add(AuthUpdateSecurityPreferences(
          preferences: {'testSetting': true},
        )),
        expect: () => [
          AuthProfileUpdateSuccess(
            updatedData: {'testSetting': true},
            successMessage: contains('bijgewerkt'), // Dutch success message
          ),
        ],
      );
    });
  });
}