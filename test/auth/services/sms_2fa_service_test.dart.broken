import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:securyflex_app/auth/services/sms_2fa_service.dart';
import 'package:securyflex_app/auth/models/enhanced_auth_models.dart';
import 'package:securyflex_app/auth/auth_service.dart';

/// Mock Firebase Auth for testing
class MockFirebaseAuth extends Mock implements FirebaseAuth {}

/// Mock PhoneAuthCredential for testing  
class MockPhoneAuthCredential extends Mock implements PhoneAuthCredential {}

/// Mock User for Firebase Auth testing
class MockUser extends Mock implements User {}

/// Mock UserCredential for Firebase Auth testing
class MockUserCredential extends Mock implements UserCredential {}

/// Mock SharedPreferences for testing
class MockSharedPreferences extends Mock implements SharedPreferences {}

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  group('SMS 2FA Service Tests', () {
    late MockFirebaseAuth mockAuth;
    late MockSharedPreferences mockPrefs;
    late MockUser mockUser;

    setUp(() {
      mockAuth = MockFirebaseAuth();
      mockPrefs = MockSharedPreferences();
      mockUser = MockUser();
      
      SharedPreferences.setMockInitialValues({});
      
      // Default mocks for basic operations
      when(() => mockAuth.currentUser).thenReturn(mockUser);
      when(() => mockUser.uid).thenReturn('test-user-123');
      when(() => mockPrefs.setString(any(), any())).thenAnswer((_) async => true);
      when(() => mockPrefs.getString(any())).thenReturn(null);
    });

    group('Phone Number Validation', () {
      test('should validate Dutch phone numbers correctly', () {
        // Valid Dutch phone numbers
        expect(SMS2FAService.isValidDutchPhoneNumber('+31612345678'), isTrue);
        expect(SMS2FAService.isValidDutchPhoneNumber('0612345678'), isTrue);
        expect(SMS2FAService.isValidDutchPhoneNumber('+31 6 12345678'), isTrue);
        expect(SMS2FAService.isValidDutchPhoneNumber('06-12345678'), isTrue);
        expect(SMS2FAService.isValidDutchPhoneNumber('06 1234 5678'), isTrue);
        
        // Invalid phone numbers
        expect(SMS2FAService.isValidDutchPhoneNumber('+32612345678'), isFalse); // Belgian
        expect(SMS2FAService.isValidDutchPhoneNumber('612345678'), isFalse); // Missing prefix
        expect(SMS2FAService.isValidDutchPhoneNumber('+3161234567'), isFalse); // Too short
        expect(SMS2FAService.isValidDutchPhoneNumber('+316123456789'), isFalse); // Too long
        expect(SMS2FAService.isValidDutchPhoneNumber(''), isFalse); // Empty
        expect(SMS2FAService.isValidDutchPhoneNumber('+31512345678'), isFalse); // Landline
      });

      test('should normalize phone numbers to international format', () {
        expect(SMS2FAService.normalizeDutchPhoneNumber('0612345678'), equals('+31612345678'));
        expect(SMS2FAService.normalizeDutchPhoneNumber('06-12345678'), equals('+31612345678'));
        expect(SMS2FAService.normalizeDutchPhoneNumber('06 1234 5678'), equals('+31612345678'));
        expect(SMS2FAService.normalizeDutchPhoneNumber('+31612345678'), equals('+31612345678'));
        expect(SMS2FAService.normalizeDutchPhoneNumber('+31 6 12345678'), equals('+31612345678'));
      });

      test('should throw exception for invalid phone numbers during normalization', () {
        expect(() => SMS2FAService.normalizeDutchPhoneNumber('invalid'), 
               throwsA(isA<ArgumentError>()));
        expect(() => SMS2FAService.normalizeDutchPhoneNumber(''), 
               throwsA(isA<ArgumentError>()));
        expect(() => SMS2FAService.normalizeDutchPhoneNumber('+32612345678'), 
               throwsA(isA<ArgumentError>()));
      });
    });

    group('SMS 2FA Setup', () {
      test('should setup SMS 2FA for valid phone number', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        when(() => mockPrefs.setString(any(), any())).thenAnswer((_) async => true);
        
        final result = await SMS2FAService.setupSMS2FA(
          userId: userId,
          phoneNumber: phoneNumber,
        );
        
        expect(result, isTrue);
        verify(() => mockPrefs.setString('sms_2fa_$userId', any())).called(1);
      });

      test('should reject invalid phone number during setup', () async {
        const userId = 'test-user-123';
        const invalidPhoneNumber = 'invalid-phone';
        
        expect(
          () => SMS2FAService.setupSMS2FA(
            userId: userId,
            phoneNumber: invalidPhoneNumber,
          ),
          throwsA(isA<ArgumentError>()),
        );
        
        verifyNever(() => mockPrefs.setString(any(), any()));
      });

      test('should enable SMS 2FA configuration after successful setup', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        when(() => mockPrefs.setString(any(), any())).thenAnswer((_) async => true);
        
        await SMS2FAService.setupSMS2FA(
          userId: userId,
          phoneNumber: phoneNumber,
        );
        
        // Verify that configuration is stored with correct structure
        final capturedConfig = verify(() => mockPrefs.setString('sms_2fa_$userId', captureAny()))
            .captured.first as String;
        
        expect(capturedConfig, contains('isEnabled'));
        expect(capturedConfig, contains(phoneNumber));
        expect(capturedConfig, contains('setupDate'));
      });
    });

    group('SMS Code Sending', () {
      test('should send verification code for valid phone number', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        // Mock Firebase Phone Auth
        when(() => mockAuth.verifyPhoneNumber(
          phoneNumber: phoneNumber,
          verificationCompleted: any(named: 'verificationCompleted'),
          verificationFailed: any(named: 'verificationFailed'),
          codeSent: any(named: 'codeSent'),
          codeAutoRetrievalTimeout: any(named: 'codeAutoRetrievalTimeout'),
          timeout: any(named: 'timeout'),
        )).thenAnswer((invocation) async {
          // Simulate successful code sent
          final codeSent = invocation.namedArguments[const Symbol('codeSent')] 
              as void Function(String, int?);
          codeSent('mock-verification-id', 60);
        });
        
        final result = await SMS2FAService.sendVerificationCode(
          userId: userId,
          phoneNumber: phoneNumber,
        );
        
        expect(result.success, isTrue);
        expect(result.verificationId, equals('mock-verification-id'));
        expect(result.cooldownSeconds, equals(60));
        expect(result.messageDutch, contains('Verificatiecode verstuurd'));
      });

      test('should handle phone number format during code sending', () async {
        const userId = 'test-user-123';
        const phoneNumber = '0612345678'; // Dutch format
        const expectedNormalized = '+31612345678';
        
        when(() => mockAuth.verifyPhoneNumber(
          phoneNumber: expectedNormalized,
          verificationCompleted: any(named: 'verificationCompleted'),
          verificationFailed: any(named: 'verificationFailed'),
          codeSent: any(named: 'codeSent'),
          codeAutoRetrievalTimeout: any(named: 'codeAutoRetrievalTimeout'),
          timeout: any(named: 'timeout'),
        )).thenAnswer((invocation) async {
          final codeSent = invocation.namedArguments[const Symbol('codeSent')] 
              as void Function(String, int?);
          codeSent('verification-id', 60);
        });
        
        final result = await SMS2FAService.sendVerificationCode(
          userId: userId,
          phoneNumber: phoneNumber,
        );
        
        expect(result.success, isTrue);
        verify(() => mockAuth.verifyPhoneNumber(
          phoneNumber: expectedNormalized,
          verificationCompleted: any(named: 'verificationCompleted'),
          verificationFailed: any(named: 'verificationFailed'),
          codeSent: any(named: 'codeSent'),
          codeAutoRetrievalTimeout: any(named: 'codeAutoRetrievalTimeout'),
          timeout: any(named: 'timeout'),
        )).called(1);
      });

      test('should implement rate limiting for SMS sending', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        // Mock configuration with recent SMS sent
        final recentTime = DateTime.now().subtract(const Duration(seconds: 30));
        final configJson = '''
        {
          "isEnabled": true,
          "phoneNumber": "$phoneNumber",
          "lastSmsSentAt": "${recentTime.toIso8601String()}",
          "dailySmsCount": 1,
          "lastResetDate": "${DateTime.now().toIso8601String()}"
        }
        ''';
        
        when(() => mockPrefs.getString('sms_2fa_$userId')).thenReturn(configJson);
        
        final result = await SMS2FAService.sendVerificationCode(
          userId: userId,
          phoneNumber: phoneNumber,
        );
        
        expect(result.success, isFalse);
        expect(result.errorCode, equals('RATE_LIMITED'));
        expect(result.errorMessageDutch, contains('Te vroeg'));
        expect(result.cooldownSeconds, greaterThan(0));
      });

      test('should allow resend after cooldown period', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        // Mock configuration with old SMS sent (>60 seconds ago)
        final oldTime = DateTime.now().subtract(const Duration(seconds: 120));
        final configJson = '''
        {
          "isEnabled": true,
          "phoneNumber": "$phoneNumber",
          "lastSmsSentAt": "${oldTime.toIso8601String()}",
          "dailySmsCount": 1,
          "lastResetDate": "${DateTime.now().toIso8601String()}"
        }
        ''';
        
        when(() => mockPrefs.getString('sms_2fa_$userId')).thenReturn(configJson);
        when(() => mockAuth.verifyPhoneNumber(
          phoneNumber: any(named: 'phoneNumber'),
          verificationCompleted: any(named: 'verificationCompleted'),
          verificationFailed: any(named: 'verificationFailed'),
          codeSent: any(named: 'codeSent'),
          codeAutoRetrievalTimeout: any(named: 'codeAutoRetrievalTimeout'),
          timeout: any(named: 'timeout'),
        )).thenAnswer((invocation) async {
          final codeSent = invocation.namedArguments[const Symbol('codeSent')] 
              as void Function(String, int?);
          codeSent('new-verification-id', 60);
        });
        
        final result = await SMS2FAService.sendVerificationCode(
          userId: userId,
          phoneNumber: phoneNumber,
          isResend: true,
        );
        
        expect(result.success, isTrue);
        expect(result.verificationId, equals('new-verification-id'));
        expect(result.messageDutch, contains('opnieuw verstuurd'));
      });

      test('should enforce daily SMS limits', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        // Mock configuration with maximum daily SMS count reached
        final configJson = '''
        {
          "isEnabled": true,
          "phoneNumber": "$phoneNumber",
          "dailySmsCount": 10,
          "lastResetDate": "${DateTime.now().toIso8601String()}"
        }
        ''';
        
        when(() => mockPrefs.getString('sms_2fa_$userId')).thenReturn(configJson);
        
        final result = await SMS2FAService.sendVerificationCode(
          userId: userId,
          phoneNumber: phoneNumber,
        );
        
        expect(result.success, isFalse);
        expect(result.errorCode, equals('DAILY_LIMIT_EXCEEDED'));
        expect(result.errorMessageDutch, contains('dagelijkse limiet'));
      });

      test('should handle Firebase verification failures', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        when(() => mockAuth.verifyPhoneNumber(
          phoneNumber: any(named: 'phoneNumber'),
          verificationCompleted: any(named: 'verificationCompleted'),
          verificationFailed: any(named: 'verificationFailed'),
          codeSent: any(named: 'codeSent'),
          codeAutoRetrievalTimeout: any(named: 'codeAutoRetrievalTimeout'),
          timeout: any(named: 'timeout'),
        )).thenAnswer((invocation) async {
          final verificationFailed = invocation.namedArguments[const Symbol('verificationFailed')] 
              as void Function(FirebaseAuthException);
          verificationFailed(FirebaseAuthException(
            code: 'too-many-requests',
            message: 'Too many requests',
          ));
        });
        
        final result = await SMS2FAService.sendVerificationCode(
          userId: userId,
          phoneNumber: phoneNumber,
        );
        
        expect(result.success, isFalse);
        expect(result.errorCode, equals('too-many-requests'));
        expect(result.errorMessageDutch, contains('Te veel verzoeken'));
      });
    });

    group('SMS Code Verification', () {
      test('should verify valid SMS code', () async {
        const userId = 'test-user-123';
        const code = '123456';
        const verificationId = 'mock-verification-id';
        
        final mockCredential = MockPhoneAuthCredential();
        final mockUserCredential = MockUserCredential();
        
        when(() => PhoneAuthProvider.credential(
          verificationId: verificationId,
          smsCode: code,
        )).thenReturn(mockCredential);
        
        when(() => mockAuth.signInWithCredential(mockCredential))
            .thenAnswer((_) async => mockUserCredential);
        when(() => mockUserCredential.user).thenReturn(mockUser);
        
        final result = await SMS2FAService.verifyCode(
          userId: userId,
          code: code,
          verificationId: verificationId,
        );
        
        expect(result.success, isTrue);
        expect(result.messageDutch, contains('Verificatie succesvol'));
      });

      test('should reject invalid SMS code', () async {
        const userId = 'test-user-123';
        const code = 'wrong';
        const verificationId = 'mock-verification-id';
        
        final mockCredential = MockPhoneAuthCredential();
        
        when(() => PhoneAuthProvider.credential(
          verificationId: verificationId,
          smsCode: code,
        )).thenReturn(mockCredential);
        
        when(() => mockAuth.signInWithCredential(mockCredential))
            .thenThrow(FirebaseAuthException(
              code: 'invalid-verification-code',
              message: 'Invalid verification code',
            ));
        
        final result = await SMS2FAService.verifyCode(
          userId: userId,
          code: code,
          verificationId: verificationId,
        );
        
        expect(result.success, isFalse);
        expect(result.errorCode, equals('invalid-verification-code'));
        expect(result.errorMessageDutch, contains('Ongeldige verificatiecode'));
      });

      test('should handle verification code expiration', () async {
        const userId = 'test-user-123';
        const code = '123456';
        const verificationId = 'expired-verification-id';
        
        final mockCredential = MockPhoneAuthCredential();
        
        when(() => PhoneAuthProvider.credential(
          verificationId: verificationId,
          smsCode: code,
        )).thenReturn(mockCredential);
        
        when(() => mockAuth.signInWithCredential(mockCredential))
            .thenThrow(FirebaseAuthException(
              code: 'session-expired',
              message: 'Session expired',
            ));
        
        final result = await SMS2FAService.verifyCode(
          userId: userId,
          code: code,
          verificationId: verificationId,
        );
        
        expect(result.success, isFalse);
        expect(result.errorCode, equals('session-expired'));
        expect(result.errorMessageDutch, contains('sessie verlopen'));
      });

      test('should track failed verification attempts', () async {
        const userId = 'test-user-123';
        const code = 'wrong';
        const verificationId = 'mock-verification-id';
        
        // Mock existing configuration
        final configJson = '''
        {
          "isEnabled": true,
          "phoneNumber": "+31612345678",
          "failedAttempts": 1
        }
        ''';
        
        when(() => mockPrefs.getString('sms_2fa_$userId')).thenReturn(configJson);
        when(() => mockPrefs.setString(any(), any())).thenAnswer((_) async => true);
        
        final mockCredential = MockPhoneAuthCredential();
        when(() => PhoneAuthProvider.credential(
          verificationId: verificationId,
          smsCode: code,
        )).thenReturn(mockCredential);
        
        when(() => mockAuth.signInWithCredential(mockCredential))
            .thenThrow(FirebaseAuthException(
              code: 'invalid-verification-code',
              message: 'Invalid code',
            ));
        
        final result = await SMS2FAService.verifyCode(
          userId: userId,
          code: code,
          verificationId: verificationId,
        );
        
        expect(result.success, isFalse);
        expect(result.remainingAttempts, lessThan(5)); // Default max attempts
        
        // Verify that failed attempts were incremented and saved
        verify(() => mockPrefs.setString('sms_2fa_$userId', any())).called(1);
      });

      test('should lockout user after maximum failed attempts', () async {
        const userId = 'test-user-123';
        const code = 'wrong';
        const verificationId = 'mock-verification-id';
        
        // Mock configuration with maximum failed attempts
        final configJson = '''
        {
          "isEnabled": true,
          "phoneNumber": "+31612345678",
          "failedAttempts": 5,
          "lockedUntil": "${DateTime.now().add(Duration(minutes: 15)).toIso8601String()}"
        }
        ''';
        
        when(() => mockPrefs.getString('sms_2fa_$userId')).thenReturn(configJson);
        
        final result = await SMS2FAService.verifyCode(
          userId: userId,
          code: code,
          verificationId: verificationId,
        );
        
        expect(result.success, isFalse);
        expect(result.errorCode, equals('ACCOUNT_LOCKED'));
        expect(result.errorMessageDutch, contains('tijdelijk vergrendeld'));
        expect(result.lockTimeRemaining, isNotNull);
      });

      test('should reset failed attempts on successful verification', () async {
        const userId = 'test-user-123';
        const code = '123456';
        const verificationId = 'mock-verification-id';
        
        // Mock configuration with some failed attempts
        final configJson = '''
        {
          "isEnabled": true,
          "phoneNumber": "+31612345678",
          "failedAttempts": 3
        }
        ''';
        
        when(() => mockPrefs.getString('sms_2fa_$userId')).thenReturn(configJson);
        when(() => mockPrefs.setString(any(), any())).thenAnswer((_) async => true);
        
        final mockCredential = MockPhoneAuthCredential();
        final mockUserCredential = MockUserCredential();
        
        when(() => PhoneAuthProvider.credential(
          verificationId: verificationId,
          smsCode: code,
        )).thenReturn(mockCredential);
        
        when(() => mockAuth.signInWithCredential(mockCredential))
            .thenAnswer((_) async => mockUserCredential);
        when(() => mockUserCredential.user).thenReturn(mockUser);
        
        final result = await SMS2FAService.verifyCode(
          userId: userId,
          code: code,
          verificationId: verificationId,
        );
        
        expect(result.success, isTrue);
        
        // Verify that configuration was updated to reset failed attempts
        final capturedConfig = verify(() => mockPrefs.setString('sms_2fa_$userId', captureAny()))
            .captured.first as String;
        expect(capturedConfig, contains('"failedAttempts":0'));
      });
    });

    group('Configuration Management', () {
      test('should load SMS 2FA configuration correctly', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        final configJson = '''
        {
          "isEnabled": true,
          "phoneNumber": "$phoneNumber",
          "setupDate": "2023-01-01T00:00:00.000Z",
          "failedAttempts": 0,
          "dailySmsCount": 2,
          "lastResetDate": "2023-01-01T00:00:00.000Z"
        }
        ''';
        
        when(() => mockPrefs.getString('sms_2fa_$userId')).thenReturn(configJson);
        
        final config = await SMS2FAService.getSMS2FAConfig(userId);
        
        expect(config?.isEnabled, isTrue);
        expect(config?.phoneNumber, equals(phoneNumber));
        expect(config?.setupDate, isNotNull);
        expect(config?.failedAttempts, equals(0));
        expect(config?.dailySmsCount, equals(2));
      });

      test('should return null for non-existent configuration', () async {
        const userId = 'test-user-no-config';
        
        when(() => mockPrefs.getString('sms_2fa_$userId')).thenReturn(null);
        
        final config = await SMS2FAService.getSMS2FAConfig(userId);
        
        expect(config, isNull);
      });

      test('should handle corrupted configuration gracefully', () async {
        const userId = 'test-user-corrupted';
        
        when(() => mockPrefs.getString('sms_2fa_$userId')).thenReturn('invalid{json}');
        
        final config = await SMS2FAService.getSMS2FAConfig(userId);
        
        expect(config, isNull);
      });

      test('should disable SMS 2FA with valid verification', () async {
        const userId = 'test-user-123';
        const verificationCode = '123456';
        
        // Mock valid configuration
        final configJson = '''
        {
          "isEnabled": true,
          "phoneNumber": "+31612345678"
        }
        ''';
        
        when(() => mockPrefs.getString('sms_2fa_$userId')).thenReturn(configJson);
        when(() => mockPrefs.remove(any())).thenAnswer((_) async => true);
        
        // Mock successful verification
        final mockCredential = MockPhoneAuthCredential();
        final mockUserCredential = MockUserCredential();
        
        when(() => PhoneAuthProvider.credential(
          verificationId: any(named: 'verificationId'),
          smsCode: verificationCode,
        )).thenReturn(mockCredential);
        
        when(() => mockAuth.signInWithCredential(mockCredential))
            .thenAnswer((_) async => mockUserCredential);
        when(() => mockUserCredential.user).thenReturn(mockUser);
        
        final result = await SMS2FAService.disableSMS2FA(
          userId: userId,
          verificationCode: verificationCode,
        );
        
        expect(result, isTrue);
        verify(() => mockPrefs.remove('sms_2fa_$userId')).called(1);
      });

      test('should reject disable request without valid verification', () async {
        const userId = 'test-user-123';
        const verificationCode = 'wrong';
        
        final configJson = '''
        {
          "isEnabled": true,
          "phoneNumber": "+31612345678"
        }
        ''';
        
        when(() => mockPrefs.getString('sms_2fa_$userId')).thenReturn(configJson);
        
        // Mock failed verification
        final mockCredential = MockPhoneAuthCredential();
        when(() => PhoneAuthProvider.credential(
          verificationId: any(named: 'verificationId'),
          smsCode: verificationCode,
        )).thenReturn(mockCredential);
        
        when(() => mockAuth.signInWithCredential(mockCredential))
            .thenThrow(FirebaseAuthException(
              code: 'invalid-verification-code',
              message: 'Invalid code',
            ));
        
        final result = await SMS2FAService.disableSMS2FA(
          userId: userId,
          verificationCode: verificationCode,
        );
        
        expect(result, isFalse);
        verifyNever(() => mockPrefs.remove(any()));
      });
    });

    group('Security Features', () {
      test('should implement fraud detection for suspicious patterns', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        // Simulate rapid repeated requests (potential fraud)
        for (int i = 0; i < 5; i++) {
          when(() => mockAuth.verifyPhoneNumber(
            phoneNumber: any(named: 'phoneNumber'),
            verificationCompleted: any(named: 'verificationCompleted'),
            verificationFailed: any(named: 'verificationFailed'),
            codeSent: any(named: 'codeSent'),
            codeAutoRetrievalTimeout: any(named: 'codeAutoRetrievalTimeout'),
            timeout: any(named: 'timeout'),
          )).thenAnswer((invocation) async {
            final codeSent = invocation.namedArguments[const Symbol('codeSent')] 
                as void Function(String, int?);
            codeSent('verification-id-$i', 60);
          });
          
          await SMS2FAService.sendVerificationCode(
            userId: userId,
            phoneNumber: phoneNumber,
          );
        }
        
        // Next request should be flagged as suspicious
        final suspiciousResult = await SMS2FAService.sendVerificationCode(
          userId: userId,
          phoneNumber: phoneNumber,
        );
        
        expect(suspiciousResult.success, isFalse);
        expect(suspiciousResult.errorCode, anyOf(['RATE_LIMITED', 'FRAUD_DETECTED']));
      });

      test('should track verification attempts per device/session', () async {
        const userId = 'test-user-123';
        const deviceId = 'test-device-123';
        
        // Mock device tracking
        final result = await SMS2FAService.trackDeviceVerification(
          userId: userId,
          deviceId: deviceId,
          verificationResult: true,
        );
        
        expect(result, isNotNull);
        expect(result['deviceId'], equals(deviceId));
        expect(result['lastVerification'], isNotNull);
      });

      test('should sanitize phone numbers in logs', () {
        const phoneNumber = '+31612345678';
        const sanitized = SMS2FAService.sanitizePhoneNumberForLogging(phoneNumber);
        
        expect(sanitized, equals('+316****5678'));
        expect(sanitized, isNot(equals(phoneNumber)));
        expect(sanitized.length, lessThan(phoneNumber.length));
      });

      test('should validate phone number against known fraud patterns', () {
        // Test various suspicious phone number patterns
        expect(SMS2FAService.isSuspiciousPhoneNumber('+31600000000'), isTrue); // Sequential zeros
        expect(SMS2FAService.isSuspiciousPhoneNumber('+31611111111'), isTrue); // Repeating digits
        expect(SMS2FAService.isSuspiciousPhoneNumber('+31612345678'), isFalse); // Normal number
        expect(SMS2FAService.isSuspiciousPhoneNumber('+31698765432'), isFalse); // Normal number
      });
    });

    group('Error Handling and Edge Cases', () {
      test('should handle network connectivity issues', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        when(() => mockAuth.verifyPhoneNumber(
          phoneNumber: any(named: 'phoneNumber'),
          verificationCompleted: any(named: 'verificationCompleted'),
          verificationFailed: any(named: 'verificationFailed'),
          codeSent: any(named: 'codeSent'),
          codeAutoRetrievalTimeout: any(named: 'codeAutoRetrievalTimeout'),
          timeout: any(named: 'timeout'),
        )).thenThrow(Exception('Network error'));
        
        final result = await SMS2FAService.sendVerificationCode(
          userId: userId,
          phoneNumber: phoneNumber,
        );
        
        expect(result.success, isFalse);
        expect(result.errorCode, equals('NETWORK_ERROR'));
        expect(result.errorMessageDutch, contains('netwerkfout'));
      });

      test('should handle Firebase service unavailable', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        when(() => mockAuth.verifyPhoneNumber(
          phoneNumber: any(named: 'phoneNumber'),
          verificationCompleted: any(named: 'verificationCompleted'),
          verificationFailed: any(named: 'verificationFailed'),
          codeSent: any(named: 'codeSent'),
          codeAutoRetrievalTimeout: any(named: 'codeAutoRetrievalTimeout'),
          timeout: any(named: 'timeout'),
        )).thenAnswer((invocation) async {
          final verificationFailed = invocation.namedArguments[const Symbol('verificationFailed')] 
              as void Function(FirebaseAuthException);
          verificationFailed(FirebaseAuthException(
            code: 'network-request-failed',
            message: 'Network request failed',
          ));
        });
        
        final result = await SMS2FAService.sendVerificationCode(
          userId: userId,
          phoneNumber: phoneNumber,
        );
        
        expect(result.success, isFalse);
        expect(result.errorCode, equals('network-request-failed'));
        expect(result.errorMessageDutch, contains('netwerkverzoek mislukt'));
      });

      test('should handle quota exceeded errors', () async {
        const userId = 'test-user-123';
        const phoneNumber = '+31612345678';
        
        when(() => mockAuth.verifyPhoneNumber(
          phoneNumber: any(named: 'phoneNumber'),
          verificationCompleted: any(named: 'verificationFailed'),
          verificationFailed: any(named: 'verificationFailed'),
          codeSent: any(named: 'codeSent'),
          codeAutoRetrievalTimeout: any(named: 'codeAutoRetrievalTimeout'),
          timeout: any(named: 'timeout'),
        )).thenAnswer((invocation) async {
          final verificationFailed = invocation.namedArguments[const Symbol('verificationFailed')] 
              as void Function(FirebaseAuthException);
          verificationFailed(FirebaseAuthException(
            code: 'quota-exceeded',
            message: 'SMS quota exceeded',
          ));
        });
        
        final result = await SMS2FAService.sendVerificationCode(
          userId: userId,
          phoneNumber: phoneNumber,
        );
        
        expect(result.success, isFalse);
        expect(result.errorCode, equals('quota-exceeded'));
        expect(result.errorMessageDutch, contains('quotum overschreden'));
      });

      test('should handle malformed verification ID', () async {
        const userId = 'test-user-123';
        const code = '123456';
        const malformedVerificationId = '';
        
        final result = await SMS2FAService.verifyCode(
          userId: userId,
          code: code,
          verificationId: malformedVerificationId,
        );
        
        expect(result.success, isFalse);
        expect(result.errorCode, equals('INVALID_VERIFICATION_ID'));
        expect(result.errorMessageDutch, contains('Ongeldige verificatie ID'));
      });
    });

    group('Dutch Localization', () {
      test('should provide Dutch error messages for all scenarios', () {
        final errorMessages = SMS2FAService.getDutchErrorMessages();
        
        expect(errorMessages['invalid-phone-number'], 
               contains('telefoonnummer'));
        expect(errorMessages['too-many-requests'], 
               contains('Te veel verzoeken'));
        expect(errorMessages['network-request-failed'], 
               contains('netwerkverzoek'));
        expect(errorMessages['session-expired'], 
               contains('sessie verlopen'));
        expect(errorMessages['quota-exceeded'], 
               contains('quotum overschreden'));
      });

      test('should format Dutch phone numbers for display', () {
        expect(SMS2FAService.formatPhoneNumberForDisplay('+31612345678'), 
               equals('06 1234 5678'));
        expect(SMS2FAService.formatPhoneNumberForDisplay('+31687654321'), 
               equals('06 8765 4321'));
      });

      test('should provide Dutch status descriptions', () {
        final config = SMS2FAConfig(
          isEnabled: true,
          phoneNumber: '+31612345678',
          setupDate: DateTime.now(),
          failedAttempts: 2,
          dailySmsCount: 3,
        );
        
        final statusDutch = SMS2FAService.getStatusDescriptionDutch(config);
        expect(statusDutch, contains('ingeschakeld'));
        expect(statusDutch, contains('06 1234 5678'));
      });
    });

    group('Performance and Scalability', () {
      test('should handle concurrent verification requests', () async {
        const userId = 'test-user-concurrent';
        const phoneNumber = '+31612345678';
        
        when(() => mockAuth.verifyPhoneNumber(
          phoneNumber: any(named: 'phoneNumber'),
          verificationCompleted: any(named: 'verificationCompleted'),
          verificationFailed: any(named: 'verificationFailed'),
          codeSent: any(named: 'codeSent'),
          codeAutoRetrievalTimeout: any(named: 'codeAutoRetrievalTimeout'),
          timeout: any(named: 'timeout'),
        )).thenAnswer((invocation) async {
          final codeSent = invocation.namedArguments[const Symbol('codeSent')] 
              as void Function(String, int?);
          codeSent('concurrent-verification-id', 60);
        });
        
        // Send multiple concurrent requests
        final futures = List.generate(3, (_) => SMS2FAService.sendVerificationCode(
          userId: userId,
          phoneNumber: phoneNumber,
        ));
        
        final results = await Future.wait(futures);
        
        // Should handle concurrent requests gracefully
        expect(results.length, equals(3));
        
        // At least one should succeed, others might be rate limited
        final successfulResults = results.where((r) => r.success).toList();
        expect(successfulResults.length, greaterThanOrEqualTo(1));
      });

      test('should clean up expired verification sessions', () async {
        // Mock cleanup of old verification data
        final cleanedCount = await SMS2FAService.cleanupExpiredSessions();
        
        expect(cleanedCount, isA<int>());
        expect(cleanedCount, greaterThanOrEqualTo(0));
      });

      test('should optimize storage usage', () async {
        const userId = 'test-user-optimization';
        
        // Simulate storing and optimizing configuration
        await SMS2FAService.optimizeConfigurationStorage(userId);
        
        // Verify that unnecessary data is cleaned up
        // This would test compression of configuration data, removal of old entries, etc.
      });
    });
  });
}